#面向对象
封装 继承 多态
##类和对象
类抽象,对象是类的实现
##定义类
例:
public class 类名 {
    成员变量
    成员方法(包含构造方法)
}
##创建对象
例
类名 对象名 = new 类名();
这个对象就是类的实例

##类的封装
类中有一些属性,变量名称如果泄露出去会很麻烦,这时需要在类中用private修饰,这样此变量只能通过同一个类中的其他public方法读取和更改.

##构造方法
写在类之中的一种特殊方法,与类同名,在类被实例化(创建对象)时自动执行.
定义构造方法要求:
1.方法的名称必须与类同名
2.在方法名称前没有返回值类型的声明
3.在方法体中不可以使用return返回值,但可以单独写return作为方法结束.
用处嘛,比如可以在创建对象时写用来接收参数并赋值给成员变量的方法.
构造方法也可以重载.及多个同名的方法,根据接收参数类型和数量不同选择执行.

##this关键字
this指方法所在对象.
可以解决成员变量和成员内部的变量名冲突的问题,比如:
例
public class colorful{
    String color;
    public colorful(String color){
        this.color = color;
    }
}
成员方法中使用的this.color指本对象的成员变量,直接使用color指成员方法中的变量.

##this调用构造方法
只有构造方法才能通过this([参数类型 参数1....])来调用其他构造方法.只能调用一次而且必须写在第一行.
比如说传入3个参数,却需要调用只传入2个参数时的构造方法,这时就可以通过this来调用.
2个构造方法之间不能通过this互相调用,否则会导致无限循环所以编译报错.

##static 关键字:静态
当以一个类创建多个对象时,会为每个对象分配内存.如果类中有一个变量,就会在每个对象中各有各的.如果想让所有对象共享同一个变量,就需要在类中用static修饰这个成员变量.这样访问时可以通过"任意对象.变量名"或者"类名.变量名"访问一个变量,也不会消耗更多内存.

注意这个变量一定是类的成员变量,而不是类中方法的局部变量.

##静态方法 
因为方法总是写在对象之中的,使用方法就需要先创建对象(JS最外面有document这个对象,所有也可以认为是写在对象里的).
但静态方法可以用"类名.方法名"直接调用,不需要提前创建对象.
静态方法中只能访问用static修饰的成员,因为其他成员需要创建对象才能访问,而静态变量不需要对象直接加载进内存的.

##静态代码块
代码块:用{}扩起来的若干行代码被称为代码块
静态代码块:在类中用static修饰的{}
例:
public class Car{
    static String color;
    static {
        color ="red";
    }
}
在类被加载时(即JVM读取这个类,验证并塞到内存里时),就会把类里所有用static修饰的变量和代码块执行一遍,完成初始化.
因为类被加载后就一直在内存,下次就从内存里找现成的,所以静态代码块只会在加载时执行一次.

##类的继承 关键字 extends
格式 例 :
public class Cow extend Animal {
    //略
}
继承会使子类直接拥有父类所有的成员变量和成员方法.不用再写一遍了!
默认所有类都是Object类的子类.

##重写父类方法
在子类中写与继承来的方法同名的方法就是重写父类方法.
说起来属性也能这么做,但这就叫重新赋值了.
子类重写父类的方法时,不能使用比父类更严格的访问权限.

##super关键字
想从子类调取父类的成员变量和成员方法和构造方法,需要用到super关键字.
例:String b = super.a;
注意,这是在子类中调取父类成员的方法,而不是实现对象中调取父类.
用子类构造方法调用父类构造方法:
在子类中用super(参数)可调用父类的构造方法,super()必须写在子类构造方法的第一行,且只能出现一次.

##final关键字
final修饰的类,变量,方法不能被改变.
1.final修饰的类不能被继承
2.final修饰的方法无法被子类重写
3.final修饰的成员变量和局部变量是常量,切只能被赋值一次.

##常量
final定义的变量是常量,名称需要全部用大写字母,单词间用下划线.


##abstract,抽象类和抽象方法
抽象方法是一种特殊的方法,定义了名字但没有方法体,用abstract修饰.
抽象方法必须存放在抽象类中,抽象类同样用abstract修饰,但抽象类中可以没有抽象方法.
抽象类不可以实例化,抽象方法也不能直接调用.
抽象类需要一个子类继承它,然后实现这个子类;抽象方法需要子类重写它才能调用.

##interface,接口
接口是一种特殊的抽象类,其中只存在常量和抽象发放,不存在变量的定义和方法实现.
定义接口需要用interface修饰.
接口中定义的常量默认使用了public static final修饰;
定义的方法默认使用了public abstract修饰.
在接口中定义方法时,所有的方法必须是抽象的.

##implements,执行
接口的实现:
定义一个类来实现接口时,需要使用implements关键字.
定义一个类来实现接口时,必须实现接口中的所有方法,如果不能实现某个方法,必须写一个空实现的方法.

##接口特性归纳
1.接口的访问权限只有public和默认
2.interface是声明接口的关键字,类似class
3.允许定义接口时多重继承,通过extends 父接口1,父接口2,父接口3....
4.接口中定义的常量,默认是public static final修饰的,无需指定.
5.接口中声明的方法,默认是public abstract修饰的,无需指定.
6.接口中的方法都是抽象的,不能实例化对象.

##多态
多态是根据传来的参数类型的不同选择执行不同的方法,有点像重载.
不过重载是同一个方法名,多态是使用父类类型的变量引用一个子类类型对象.


##向上转型
父类 变量名 = new 子类名(参数);
这样就生成了一个子类对象,但却是父类的类型.
同时当然这个对象就只能看到父类中有的属性,只在子类中有的属性就被隐藏了.


##强制类型转换
目标类型 变量 = (目标类型) 值/对象的旧变量名;
子类向上转换为父类后,可以再强制转换为子类.

##instanceof,是否是某个类/接口的实例或子类实例.
对象(或者对象引用变量) instanceof 类(或接口)
简单的说是问它是不是你爸爸,是就能向上转型.

##内部匿名类
实现接口的一种方案,在传入参数的位置直接new一个匿名的类,并在其中实现所有抽象方法.

##异常
Error类:系统内部错误或资源耗尽的错误,仅靠程序本事是不能恢复的.
Exception类:异常,程序本身可以处理的错误.

##try...catch和finally,捕获异常
格式例:
try {
    //程序代码块
} catch (异常类型(如Exception) 变量名) {
    //对异常的处理
    return;
} finally {
    //无论如何都会执行的语句,用于关闭系统资源等操作
    //并不会受到return的影响
}

##throws,抛出异常
格式例:
修饰符 返回值类型 方法名([参数1,参数2... ]) throws ExceptionType1[,ExceptionType2.... ]{
    方法体} 
此处ExceptionType就是异常类型Exception或者它的某几项子类.
用throws修饰代表这个方法有可能出现异常,且这个方法自身没办法处理.
所以在调用throws修饰的方法体时,必须用try...catch处理,或者再往上抛交给上层解决.
(好像mian再往上抛就可以不管啦)

##访问权限控制
private    同一类中
default    同一类中    同一包中
protected  同一类中    同一包中    子类中
public     同一类中    同一包中    子类中    全局范围

注:子类指不同包下的子类.